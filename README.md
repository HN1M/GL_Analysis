## 📜 GL 분석 시스템 최종 청사진 (To-Be Model)

**Ⅰ. 사용자 페르소나 및 핵심 시나리오** 🧑‍💻

- **목표**: '누가', '왜', '어떻게' 이 툴을 사용하는지 명확히 하여, 기능 개발의 우선순위를 정하고 UX를 개선합니다.
- **상세 명세**:
    - **페르소나 정의**:
        - **`김감사 (3년차 회계법인 감사인)`**: 감사 조서 작성 시간을 단축하고 싶어 함. 이상 거래 샘플링의 근거를 찾는 데 많은 시간을 소요.
        - **`박팀장 (10년차 기업 재무팀장)`**: 월 결산 후 내부 검토용으로 재무 데이터의 특이사항을 빠르게 파악하고 싶어 함. 경영진 보고 자료에 포함할 인사이트가 필요.
    - **핵심 시나리오 (User Stories)**:
        - **"김감사는** 매출 계정의 급증 원인을 파악하기 위해, `위험 평가` 탭에서 '매출'과 'E(실재성)'가 교차하는 셀을 클릭하여 가장 위험도가 높은 거래 내역을 드릴다운하고, 해당 내역을 CSV로 추출하여 감사 조서에 첨부한다."
      - (임시 비활성화) `위험 평가` 탭 관련 시나리오는 현재 제거되어, 프로젝트 말미에 재도입 예정입니다.
        - **"박팀장은** 광고선전비 계정을 `AI 리포트`에서 분석하여, '신규 캠페인' 클러스터가 전기 대비 크게 증가했음을 확인하고, 해당 내용을 요약하여 월간 실적 보고 회의에 사용한다."

---

### Ⅱ. 핵심 설계 원칙 (Core Principles)

1. **계층 분리 (Layered Architecture)**: 모든 코드는 **UI(`app.py`) ↔ 서비스(`services/`) ↔ 분석(`analysis/`) ↔ 데이터(`contracts.py`)**의 4개 계층으로 엄격히 분리됩니다. 계층 간 호출은 상위에서 하위로만 가능하며, **`analysis/` 모듈은 절대 `services/`나 `ui/`를 호출할 수 없습니다.**
2. **표준 입출력 계약 (Standard I/O Contracts)**: 모든 분석 모듈은 표준 데이터 구조인 **`LedgerFrame`*을 입력받고, 결과물로 표준 DTO(Data Transfer Object)인 **`ModuleResult`*를 반환해야 합니다. 이는 모듈의 독립성과 조합성을 보장합니다.
3. **상태 없음 (Stateless Modules)**: `analysis/` 모듈은 내부 상태를 가지지 않는 순수 함수(Pure Function)처럼 동작해야 합니다. 동일 입력에 대해 항상 동일 출력을 보장하여 예측 가능성과 테스트 용이성을 높입니다.
4. **중앙화된 외부 연동 (Centralized Services)**: LLM 호출, 외부 API(휴일 정보 등), 캐시 관리 등 모든 외부 의존성은 `services/` 계층에서만 처리합니다. 분석 로직의 순수성을 유지하기 위함입니다.
5. **위험 중심 설계 (Risk-Driven Design)**: 모든 분석 결과(`EvidenceDetail`)는 최종적으로 통계적 유의성과 재무적 중요성(**PM**)을 결합한 **통합 위험 점수**로 귀결되어야 합니다.

---

### **Ⅲ. 데이터 계약 (Data Contracts)** 📜

- **목표**: 시스템 전체에서 데이터가 이동하는 형태를 명확히 정의하여, 모듈 간의 안정적인 통신을 보장합니다.
- **담당 모듈**: `analysis/contracts.py`
- **상세 명세**:
    1. **`LedgerFrame`**: 모든 분석 모듈의 **표준 입력**.
        - `df`: 표준화된 컬럼(`회계일자`, `계정코드`, `거래금액_절대값` 등)을 가진 Pandas DataFrame.
        - `meta`: 원본 파일명, 분석 기간, `master_df` 등 분석에 필요한 메타 정보를 담는 딕셔너리.
    2. **`ModuleResult`**: 모든 분석 모듈의 **표준 출력**.
        - `name`: 모듈 이름 (e.g., "anomaly").
        - `summary`: LLM 보고서 컨텍스트에 직접 사용될 핵심 수치 요약 딕셔너리.
        - `tables`: 화면에 표시할 `pd.DataFrame` 딕셔너리.
        - `figures`: 화면에 표시할 `Plotly Figure` 딕셔너리.
        - `evidences`: 모든 발견 사항을 담는 **`EvidenceDetail`** 객체 리스트. **가장 중요한 결과물.**
        - `warnings`: 분석 중 발생한 경고 메시지 리스트.
    3. **`EvidenceDetail`**: 개별 분석 결과(이상치, 예측 이탈 등)를 담는 **표준 원자 단위**.
        - `row_id`: 원본 데이터 추적을 위한 고유 ID.
        - `reason`: 발견 사유 (e.g., "|Z|=3.5").
        - `risk_score`: 통합 위험 점수 (0~1).
        - `financial_impact`: 재무적 중요성 (거래금액 절대값).
        - `is_key_item`: PM 초과 여부 (boolean).
        - `impacted_assertions`: 연관된 주장위험 리스트 (e.g., `["C", "A"]`).
        - `links`: 계정코드, 계정명 등 드릴다운 및 상호 참조에 필요한 메타 정보.

---

### Ⅳ. 시스템 아키텍처 및 데이터 흐름

```lua
+------------------+      +-------------------+      +---------------------+      +-----------------+
|   UI (app.py)    |----->|  Services Layer   |----->|   Analysis Layer    |----->|  Data Contract  |
| (Streamlit)      |      | (LLM, Cache, API) |      | (Pandas, Stats)     |      | (LedgerFrame,   |
| - 사용자 입력    |      | - LLM 호출/요약   |      | - 순수 계산/분석    |      |  ModuleResult)  |
| - 결과 시각화    |      | - 캐시 관리       |      | - ModuleResult 생성 |      | - 데이터 구조   |
+------------------+      +-------------------+      +---------------------+      +-----------------+
```

1. **`app.py`**: 사용자가 파일을 업로드하고 분석 옵션(기간, 계정, PM)을 설정합니다.
2. **`app.py` → `analysis/`**: 분석 실행 버튼 클릭 시, `app.py`는 선택된 데이터를 `LedgerFrame`으로 감싸 각 `analysis/` 모듈의 실행 함수(`run_..._module`)를 호출합니다.
3. **`analysis/` → `services/` (필요시)**: 분석 중 LLM 요약, 외부 데이터(휴일 등)가 필요할 경우, `analysis` 모듈은 `services` 계층의 클라이언트를 호출합니다. (단, 현재 설계에서는 `analysis`가 `services`를 직접 호출하지 않고 `app.py`가 오케스트레이션하는 것을 권장합니다.)
4. **`analysis/` → `ModuleResult`**: 각 모듈은 분석 결과를 `ModuleResult` 객체에 담아 반환합니다.
5. **`app.py`**: 반환된 `ModuleResult`를 받아 `st.session_state`에 저장하고, 내부에 포함된 테이블과 플롯을 화면에 렌더링합니다.

---

### Ⅴ. 모듈별 상세 명세

| 기능 | 담당 모듈 | 역할 및 핵심 로직 | 입력 | 출력 | LLM 활용 |
| --- | --- | --- | --- | --- | --- |
| **데이터 정합성** | `analysis/integrity.py` | Master와 Ledger 간 기초/기말 잔액 및 당기 증감액 검증. 데이터 품질 지표(결측률, 텍스트 엔트로피 등) 계산. | `LedgerFrame` | `ModuleResult` (정합성 테이블, 품질 스코어) | 없음 |
| **월별 추세 분석** | `analysis/trend.py` | 계정별 CY vs PY 월별 추이(발생액/잔액) 비교. BS/PL 성격과 차/대변 특성을 반영한 시각화 생성. | `LedgerFrame` | `ModuleResult` (월별 추이 Plotly Figure) | 없음 |
| **거래처 분석** | `analysis/vendor.py` | 계정별/전체 거래처 집중도(파레토), 월별 활동성(히트맵), 특정 거래처 상세 내역(누적 막대) 분석. | `LedgerFrame` | `ModuleResult` (파레토, 히트맵 등 Figure) | 없음 |
| **상관/사이클 분석** | `analysis/correlation.py` | 계정 간 월별 흐름의 상관관계(피어슨) 계산 및 히트맵 시각화. 계정명을 기반으로 표준 회계 사이클(R2C, P2P 등)을 자동 그룹화하고, 그룹 간 상관 붕괴/지연 탐지. | `LedgerFrame` | `ModuleResult` (상관 히트맵, 사이클 경고 테이블) | **[해석]** 상관 붕괴 원인 자연어 설명, **[추천]** 계정명 기반 사이클 그룹 제안 |
| **시계열 예측** | `analysis/timeseries.py` | 계정별 월별 시계열 데이터에 최적 예측 모델(MoR: EMA/MA/ARIMA/Prophet)을 자동 적용. 최종 시점의 예측-실측 간 이탈(Error)을 계산하고 z-score, 위험 점수 산출. | `LedgerFrame` | `ModuleResult` (예측 결과 테이블, 예측 vs 실측 Figure, 예측 이탈 `EvidenceDetail` 리스트) | 없음 |
| **이상 패턴 탐지** | `analysis/anomaly.py` | **1) 통계 기반**: Z-Score, Isolation Forest를 활용한 개별 거래 이상치 탐지. **2) 법칙 기반**: 벤포드 법칙(선행 자릿수 분석). **3) AI 기반**: 적요/거래처 텍스트 임베딩 및 클러스터링(HDBSCAN/KMeans)을 통한 패턴 그룹화 및 노이즈 탐지. | `LedgerFrame` | `ModuleResult` (이상 전표 테이블, SHAP 설명 그래프, 클러스터 품질 카드, 이상치 `EvidenceDetail` 리스트) | **[이름 부여]** 텍스트 임베딩 클러스터에 LLM으로 자동 이름 부여, **[해석]** SHAP 결과를 자연어로 설명 |
| **위험 평가** | (임시 제거) | 프로젝트 말미 재도입 예정 | - | - | - |
| **AI 리포트** | `services/llm.py`, `analysis/report.py` | **1) `report.py`**: 각 `ModuleResult`의 `summary`와 `evidences`를 종합하여 LLM에 전달할 최종 컨텍스트(RAG용)를 생성. **2) `llm.py`**: 생성된 컨텍스트를 받아 지정된 프롬프트와 스키마에 따라 최종 보고서(요약/주요 발견/위험/권고) 텍스트를 생성. | `List[ModuleResult]` | 최종 보고서 `string` | **[생성]** 종합 분석 결과를 바탕으로 최종 보고서 초안 작성 |

---

### Ⅳ. 최종 디렉터리 구조 (To-Be Directory Structure) 📂

```lua
gl-analysis-system/
├── .streamlit/
│   └── config.toml         # Streamlit 앱 설정 (테마, 폰트 등)
├── analysis/
│   ├── contracts.py        # ❗ 데이터 계약 (LedgerFrame, ModuleResult, EvidenceDetail)
│   ├── integrity.py        # 데이터 정합성 및 품질 분석
│   ├── trend.py            # 월별 추세 분석
│   ├── vendor.py           # 거래처 심층 분석
│   ├── correlation.py      # 계정 간 상관/사이클 분석
│   ├── timeseries.py       # 시계열 예측 및 이탈 분석
│   ├── anomaly.py          # 통계/AI 기반 이상 패턴 탐지
│   ├── embedding.py        # 텍스트 임베딩 및 클러스터링 로직
│   └── assertion_risk.py   # (⛔ 임시 제거 대상: 프로젝트 말미 재도입 예정)
├── services/
│   ├── llm.py              # LLM(OpenAI) 호출 클라이언트 및 관련 유틸
│   ├── cache.py            # 임베딩, 예측 결과 등 비용 큰 연산 캐시 관리
│   └── external.py         # (확장용) 외부 API(휴일, 뉴스 등) 연동
├── ui/
│   └── inputs.py           # (선택) Streamlit 커스텀 입력 위젯 (예: krw_input)
├── utils/
│   ├── helpers.py          # 범용 헬퍼 함수 (find_column, add_period_tag 등)
│   ├── logger.py           # 표준 로깅 설정
│   └── viz.py              # 공통 시각화 유틸 (PM 임계선 추가 등)
├── tests/
│   ├── conftest.py         # Pytest 설정
│   ├── test_anomaly.py     # 각 분석 모듈별 단위/통합 테스트
│   ├── test_timeseries.py
│   └── ... (기타 테스트 파일)
├── .env                    # ❗ (Git 무시) API 키 등 민감 정보 저장
├── app.py                  #  애플리케이션의 메인 진입점 (Streamlit)
├── config.py               # ❗ 애플리케이션 전체 설정 (PM, 모델 파라미터 등)
├── Dockerfile              # ❗ 컨테이너화된 배포 환경 정의
├── PROJECT_BLUEPRINT.md    # ❗ 바로 이 청사진 문서
└── requirements.txt        # ❗ 프로젝트 파이썬 의존성 및 버전 고정
```

---

### Ⅶ. 환경설정 및 구성 관리 (`config.py`)

- **목표**: 코드 변경 없이 애플리케이션의 동작을 제어할 수 있도록 모든 설정을 중앙에서 관리합니다.
- **담당 모듈**: `config.py`
- **상세 명세**:
    - **LLM 설정**: `LLM_MODEL` (e.g., "gpt-4o"), `LLM_TEMPERATURE` 등 API 관련 파라미터.
    - **재무적 중요성(PM)**: `PM_DEFAULT` (기본 중요 금액).
    - **분석 모델 파라미터**: `SHAP_TOP_N` (SHAP 분석 대상 수), `TIMESERIES_MIN_POINTS` (시계열 분석 최소 데이터 기간) 등 각 분석 모듈의 핵심 변수를 정의합니다.
    - **외부 서비스 정보**: API 엔드포인트, 타임아웃 값 등.
    - **보안**: `.env` 파일을 통해 관리할 민감 정보(API 키 등)의 목록을 명시하고, `config.py`는 환경 변수에서 이를 불러오도록 설계합니다.

---

### **Ⅷ. 기술적 지속가능성 및 확장성** 🏗️

- **목표**: 미래에 기능이 추가되거나 데이터가 커져도 시스템이 흔들리지 않게 하는 기술적 기반을 정의합니다.
- **상세 명세**:
    - **아키텍처 결정 기록 (ADR)**: `adr/` 폴더를 만들어 "왜 KMeans가 아닌 HDBSCAN을 선택했는가?"와 같이 중요한 기술적/정책적 결정의 배경과 이유를 마크다운 파일로 기록합니다. 이는 **설계 의도를 보존**하여 일관성을 유지하는 데 핵심적입니다.
    - **플러그인(Plugin) 아키텍처 구상**: 장기적으로 `app.py`가 `analysis/` 폴더의 모듈을 동적으로 탐색하고 로드하는 구조를 지향합니다. 이를 통해 신규 분석 모듈 추가 시 `app.py`의 수정을 최소화하여 **확장성을 극대화**합니다.
    - **데이터 스키마 버전 관리**: `LedgerFrame` 또는 `EvidenceDetail`의 구조 변경 시 하위 호환성을 유지하기 위한 정책을 수립합니다. (예: `meta` 필드에 스키마 버전 명시)

---

### **Ⅸ. 보안 및 데이터 개인정보 보호** 🔐

- **목표**: 민감한 재무 데이터를 안전하게 처리하고 외부 서비스 연동 시 발생할 수 있는 리스크를 관리합니다.
- **담당 영역**: 전반적인 아키텍처, `services/`
- **상세 명세**:
    - **데이터 익명화/가명화**: 분석 전 민감 정보(개인 식별 정보 등)를 제거하거나 가명 처리하는 단계에 대한 정책을 명시합니다.
    - **LLM API 사용 정책**: 민감한 원본 데이터를 외부 API로 전송할 때의 비식별화 처리 규칙을 정의합니다.
    - **의존성 보안 스캔**: `requirements.txt`에 포함된 라이브러리들의 알려진 보안 취약점을 정기적으로 검사하는 절차를 추가합니다.

---

### Ⅹ. 테스트 및 품질 보증 (`tests/`)

- **목표**: 코드의 정확성과 안정성을 보장하고, 변경 사항이 기존 기능에 미치는 영향을 사전에 파악합니다.
- **담당 디렉터리**: `tests/`
- **상세 명세**:
    - **단위 테스트 (Unit Tests)**: `analysis/` 계층의 순수 계산 함수들을 대상으로 합니다. (`tests/test_anomaly.py`, `tests/test_timeseries.py`)
        - **검증 항목**: 알려진 입력값에 대해 정확한 출력값을 반환하는지, 경계값(0, null 등)을 잘 처리하는지 검증합니다.
    - **통합 테스트 (Integration Tests)**: 데이터가 `app.py` → `analysis/` → `ModuleResult`로 흐르는 전체 파이프라인이 정상 동작하는지 검증합니다. (`tests/test_pipeline.py`)
        - **검증 항목**: 소규모 샘플 엑셀 파일을 이용해 전체 분석 실행 시 오류 없이 `ModuleResult`가 생성되는지 확인합니다.
    - **스냅샷 테스트 (Snapshot Tests)**: `ModuleResult`에 포함된 시각화 결과(Plotly Figure의 JSON 표현)나 요약 테이블이 이전 버전과 동일하게 유지되는지 비교합니다. (`tests/test_snapshots.py`)
        - **검증 항목**: 코드 변경 후 의도치 않은 UI 변경이 발생했는지 자동으로 탐지합니다.

---

### **Ⅺ. 로깅 및 모니터링 (`utils/logger.py`)** 🪵

- **목표**: 애플리케이션 운영 중 발생하는 문제를 추적하고, 성능 및 사용 현황을 파악하여 개선점을 찾습니다.
- **담당 모듈**: `utils/logger.py` (신규 생성 제안)
- **상세 명세**:
    - **로그 레벨**: `INFO`, `WARNING`, `ERROR` 등 로그 레벨을 정의합니다.
        - `INFO`: 분석 시작/종료, 주요 파라미터 값 등 정상 흐름 기록.
        - `WARNING`: 데이터 품질 문제(결측치 과다), LLM 응답 지연 등 잠재적 문제 기록.
        - `ERROR`: 파일 처리 실패, API 호출 실패 등 심각한 오류 기록.
    - **로그 형식**: `[시간] [로그레벨] [모듈명] 메시지` 형식으로 통일하여 가독성을 높입니다.
    - **성능 모니터링**: 각 분석 모듈의 실행 시간을 측정하여 로그로 남기고, 병목 구간을 식별합니다.
    - **LLM 비용 추적**: `services/llm.py`에서 API 호출 시 사용된 모델과 입출력 토큰 수를 로그로 기록하여 비용을 추정합니다.

---

### **Ⅻ. 성능 목표 및 최적화 전략** ⚡

- **목표**: 대용량 데이터 처리 시에도 쾌적한 사용자 경험을 제공하기 위한 구체적인 성능 기준과 해결 전략을 정의합니다.
- **담당 영역**: `app.py`, `analysis/`, `services/cache.py`
- **상세 명세**:
    - **성능 목표 (SLA)**: "10만 건 거래 데이터 분석 시, 초기 로딩 1분 내, 각 분석 모듈은 30초 내 결과 반환"과 같이 구체적인 수치를 제시합니다.
    - **캐싱 전략 구체화**: `st.cache_data`, `st.cache_resource`, 파일 기반 영구 캐시의 명확한 사용 기준을 정의합니다.
    - **데이터 샘플링 전략**: 100만 건 이상 데이터의 경우, 임베딩이나 SHAP 분석 시에는 통계적으로 유의미한 샘플을 추출하여 분석 시간을 현실적으로 유지하는 정책을 명시합니다.

---

### **ⅩⅢ. 배포 및 의존성 관리 (`Dockerfile`, `requirements.txt`)** 🚀

- **목표**: 개발 환경과 실제 운영 환경을 일치시키고, 배포 과정을 자동화하여 안정성을 확보합니다.
- **담당 파일**: `requirements.txt`, `Dockerfile` (신규 생성 제안), `.streamlit/config.toml`
- **상세 명세**:
    - **의존성 고정**: `requirements.txt`에 모든 파이썬 라이브러리와 **정확한 버전**을 명시하여, 어느 환경에서든 동일하게 설치되도록 보장합니다.
    - **컨테이너화 (Docker)**: `Dockerfile`을 작성하여 애플리케이션을 실행하는 데 필요한 모든 환경(OS, 파이썬, 라이브러리)을 이미지로 만듭니다. 이를 통해 "제 컴퓨터에서는 됐는데..."와 같은 문제를 원천 차단합니다.
    - **배포 전략**: Streamlit Cloud, 또는 Docker 이미지를 활용한 클라우드 서비스(AWS, GCP 등) 배포 방식을 명시합니다.
    - **CI/CD (지속적 통합/배포)**: GitHub Actions 같은 도구를 사용하여, 코드 변경 시 자동으로 `tests/`를 실행하고 테스트 통과 시 지정된 서버에 배포하는 파이프라인 구축을 최종 목표로 합니다.

---

### **ⅩⅣ. 운영 및 거버넌스** 🏛️

- **목표**: 시스템이 지속적으로 개선되고 현업의 요구사항과 동기화될 수 있는 살아있는 체계를 만듭니다.
- **상세 명세**:
    - **사용자 피드백 루프**: UI에 "피드백 보내기" 기능을 추가하여 사용자의 의견(분석 오류, 개선 제안)을 체계적으로 수집하고 다음 버전 개발에 반영합니다.
    - **모델 및 규칙 재평가 정책**: 위험 점수 가중치, CEAVOP 매핑 규칙 등 핵심 비즈니스 로직을 분기별로 현업과 재검토하는 정책을 수립합니다.

---

### **ⅩⅤ. 사용자 경험(UX) 및 신뢰도 구축** 🤝

- **목표**: 사용자가 분석 결과를 신뢰하고, 복잡한 기능을 쉽고 효과적으로 사용할 수 있도록 돕는 장치를 설계합니다.
- **상세 명세**:
    - **'이 결과 설명해줘 (Explain this Result)' 기능**: 주요 분석 결과(이상치, 위험 셀) 옆에 '❓' 버튼을 두어, LLM이 해당 결과의 원인을 자연어로 설명해주는 기능을 추가합니다.
    - **파라미터 민감도 분석**: PM 값 변경 시 KIT 개수가 어떻게 변하는지 실시간으로 보여주어 사용자의 이해를 돕습니다.
    - **온보딩 및 가이드 투어**: 첫 사용자를 위한 핵심 워크플로우 안내 기능을 추가합니다.

---

### **ⅩⅥ. 문서화 및 버전 관리** 📝

- **목표**: 프로젝트의 지식을 보존하고 공유하여 팀의 협업 효율을 높이고 유지보수 비용을 절감합니다.
- **담당 파일**: `CHANGELOG.md`, `USER_GUIDE.md` 등
- **상세 명세**:
    - **코드 문서화 (Docstrings)**: 모든 함수와 클래스에 역할, 파라미터, 반환 값을 설명하는 Docstring 작성을 원칙으로 합니다.
    - **사용자 가이드 (`USER_GUIDE.md`)**: 최종 사용자를 위해 각 기능의 의미와 사용법, 결과 해석 방법을 설명합니다.
    - **변경 이력 (`CHANGELOG.md`)**: `주.부.패치` 형식의 시맨틱 버저닝을 따르며, 버전별 변경 사항(Added, Changed, Fixed)을 기록합니다.